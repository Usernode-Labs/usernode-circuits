#!/usr/bin/env python3
"""
Convert a Noir `nargo compile` JSON artifact into the raw files expected by
`usernode-circuits`.

The JSON schema generated by Noir 1.0.0-beta.11 contains two top-level fields:
`bytecode` (a base64-encoded, gzip-compressed ACIR) and `abi` (the ABI object).

Example usage:

    ./scripts/nargo_to_artifacts.py \
        --name utxo_spend \
        --artifact noir/utxo_spend/target/utxo_spend.json \
        --out-dir artifacts

The script emits `<name>.acir`, `<name>.abi.json`, and optionally updates a
manifest in the same directory when `--manifest` is supplied.
"""

from __future__ import annotations

import argparse
import base64
import gzip
import hashlib
import json
import pathlib
import sys
from typing import Any


def load_artifact(path: pathlib.Path) -> tuple[bytes, Any]:
    try:
        data = json.loads(path.read_text())
    except Exception as exc:  # noqa: BLE001
        raise SystemExit(f"failed to read artifact {path}: {exc}") from exc
    if "bytecode" not in data or "abi" not in data:
        raise SystemExit(
            f"artifact {path} missing expected fields (bytecode/abi)."
        )
    try:
        compressed = base64.b64decode(data["bytecode"], validate=True)
        acir = gzip.decompress(compressed)
    except Exception as exc:  # noqa: BLE001
        raise SystemExit(f"failed to decode ACIR for {path}: {exc}") from exc
    return acir, data["abi"]


def write_outputs(name: str, acir: bytes, abi: Any, out_dir: pathlib.Path) -> None:
    out_dir.mkdir(parents=True, exist_ok=True)
    acir_path = out_dir / f"{name}.acir"
    abi_path = out_dir / f"{name}.abi.json"
    acir_path.write_bytes(acir)
    abi_path.write_text(json.dumps(abi, indent=2, sort_keys=True))
    print(f"wrote {acir_path} ({len(acir)} bytes)")
    print(f"wrote {abi_path}")


def update_manifest(name: str, acir: bytes, abi_path: pathlib.Path, vk_path: pathlib.Path, manifest_path: pathlib.Path) -> None:
    manifest = {"version": 0, "circuits": []}
    if manifest_path.exists():
        try:
            manifest = json.loads(manifest_path.read_text())
        except Exception as exc:  # noqa: BLE001
            raise SystemExit(f"manifest parse error ({manifest_path}): {exc}") from exc
    # remove any existing entry for this circuit
    manifest["circuits"] = [
        c for c in manifest.get("circuits", []) if c.get("name") != name
    ]
    manifest["circuits"].append(
        {
            "name": name,
            "acir": f"{name}.acir",
            "abi": abi_path.name,
            "vk": vk_path.name,
            "sha256": hashlib.sha256(acir).hexdigest(),
        }
    )
    manifest_path.write_text(json.dumps(manifest, indent=2, sort_keys=True))
    print(f"updated manifest {manifest_path}")


def main() -> int:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("--name", required=True, help="Circuit name (utxo_spend, â€¦)")
    parser.add_argument("--artifact", required=True, help="Path to nargo JSON output")
    parser.add_argument(
        "--out-dir",
        required=True,
        help="Directory where .acir/.abi.json will be written",
    )
    parser.add_argument(
        "--manifest",
        help="Optional manifest.json to update with SHA256 metadata",
    )
    parser.add_argument(
        "--vk",
        help="Optional verifying key path to record in the manifest",
    )
    args = parser.parse_args()

    name = args.name
    artifact_path = pathlib.Path(args.artifact)
    out_dir = pathlib.Path(args.out_dir)
    manifest_path = pathlib.Path(args.manifest) if args.manifest else None
    vk_path = pathlib.Path(args.vk) if args.vk else out_dir / f"{name}.vk"

    acir, abi = load_artifact(artifact_path)
    write_outputs(name, acir, abi, out_dir)

    if manifest_path:
        update_manifest(name, acir, out_dir / f"{name}.abi.json", vk_path, manifest_path)

    return 0


if __name__ == "__main__":
    sys.exit(main())
