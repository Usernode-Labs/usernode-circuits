{"noir_version":"1.0.0-beta.11+fd3925aaaeb76c76319f44590d135498ef41ea6c","hash":"17891016173214000273","abi":{"parameters":[{"name":"input","type":{"kind":"struct","path":"MergeInput","fields":[{"name":"schnorr","type":{"kind":"struct","path":"Schnorr","fields":[{"name":"pk_x","type":{"kind":"field"}},{"name":"pk_y","type":{"kind":"field"}},{"name":"sig64","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"msg32","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}]}},{"name":"in0","type":{"kind":"struct","path":"Utxo","fields":[{"name":"assets_tokens","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":64}}},{"name":"assets_amounts","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":64}}},{"name":"recipient_pk_x","type":{"kind":"field"}},{"name":"salt","type":{"kind":"field"}}]}},{"name":"in1","type":{"kind":"struct","path":"Utxo","fields":[{"name":"assets_tokens","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":64}}},{"name":"assets_amounts","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":64}}},{"name":"recipient_pk_x","type":{"kind":"field"}},{"name":"salt","type":{"kind":"field"}}]}},{"name":"out","type":{"kind":"struct","path":"Utxo","fields":[{"name":"assets_tokens","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":64}}},{"name":"assets_amounts","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":64}}},{"name":"recipient_pk_x","type":{"kind":"field"}},{"name":"salt","type":{"kind":"field"}}]}}]},"visibility":"private"},{"name":"public_inputs","type":{"kind":"array","length":1,"type":{"kind":"field"}},"visibility":"public"}],"return_type":null,"error_types":{"285656119219400463":{"error_kind":"string","string":"Field failed to decompose into specified 32 limbs"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"16":{"source":"use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n","path":"std/embedded_curve_ops.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"50":{"source":"// utxo_merge: Transparent merge INS=2 -> OUTS=1\n// - Computes one output commitment committing pk_x directly (no pk-hash preimage)\n// - Enforces per-slot equality of tokens across inputs and sums their amounts\n// - Computes canonical digest with numeric tag and verifies Schnorr over it\n\nuse std::embedded_curve_ops::EmbeddedCurvePoint;\nuse dep::schnorr;\n\n// Minimal Poseidon2 sponge over BN254 using Barretenberg's exposed permutation.\ncomptime global RATE: u32 = 3; // capacity = 1\n\nfn poseidon2_hash_fields<let N: u32>(input: [Field; N]) -> Field {\n    // Domain IV: (in_len << 64) + (out_len-1), out_len=1\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (N as Field) * two_pow_64;\n    let mut state: [Field; 4] = [0; 4];\n    state[RATE] = iv;\n    let mut cache: [Field; RATE] = [0; RATE];\n    let mut cache_size: u32 = 0;\n    for i in 0..N {\n        if cache_size == RATE {\n            for j in 0..RATE { state[j] += cache[j]; }\n            state = std::hash::poseidon2_permutation(state, 4);\n            for j in 0..RATE { cache[j] = 0; }\n            cache[0] = input[i];\n            cache_size = 1;\n        } else {\n            cache[cache_size] = input[i];\n            cache_size += 1;\n        }\n    }\n    for j in 0..RATE {\n        if j < cache_size { state[j] += cache[j]; }\n    }\n    state = std::hash::poseidon2_permutation(state, 4);\n    state[0]\n}\n\nfn commit_note(pk_x: Field, tokens: [u64; 4], amounts: [u64; 4], salt: Field) -> Field {\n    // Poseidon2 over [pk_x, (t0,a0), ..., (t3,a3), salt]\n    poseidon2_hash_fields([\n        pk_x,\n        tokens[0] as Field, amounts[0] as Field,\n        tokens[1] as Field, amounts[1] as Field,\n        tokens[2] as Field, amounts[2] as Field,\n        tokens[3] as Field, amounts[3] as Field,\n        salt,\n    ])\n}\n\nstruct Schnorr { pk_x: Field, pk_y: Field, sig64: [u8; 64], msg32: [u8; 32] }\nstruct Utxo { assets_tokens: [u64; 4], assets_amounts: [u64; 4], recipient_pk_x: Field, salt: Field }\nstruct MergeInput { schnorr: Schnorr, in0: Utxo, in1: Utxo, out: Utxo }\nfn main(input: MergeInput, public_inputs: pub [Field; 1]) {\n    // Inputs must be different UTXOs (guard against double-feeding the same input)\n    let in_commit0 = commit_note(input.in0.recipient_pk_x, input.in0.assets_tokens, input.in0.assets_amounts, input.in0.salt);\n    let in_commit1 = commit_note(input.in1.recipient_pk_x, input.in1.assets_tokens, input.in1.assets_amounts, input.in1.salt);\n    assert(in_commit0 != in_commit1);\n\n    // Per-slot token equality across inputs and with output; output amounts = sum of inputs (no overflow)\n    for i in 0..4 {\n        let t0 = input.in0.assets_tokens[i];\n        let t1 = input.in1.assets_tokens[i];\n        let to = input.out.assets_tokens[i];\n        assert(t0 == t1);\n        assert(to == t0);\n        let a0 = input.in0.assets_amounts[i];\n        let a1 = input.in1.assets_amounts[i];\n        let ao = input.out.assets_amounts[i];\n        // Prevent overflow: ao must be >= a0 and ao - a0 = a1\n        assert(ao >= a0);\n        assert(ao - a0 == a1);\n    }\n\n    // Output commitment (to sender pk_x)\n    let out_commit = commit_note(input.out.recipient_pk_x, input.out.assets_tokens, input.out.assets_amounts, input.out.salt);\n    // Input commitments already computed above: in_commit0, in_commit1\n\n    // Canonical digest (tagged): [2, sender_pk_x, out_commit, 0, 0, 0]\n    let digest = poseidon2_hash_fields([\n        2, input.in0.recipient_pk_x, out_commit, 0, 0, 0\n    ]);\n\n    // Bind msg32 bytes to the computed digest by reconstructing a Field from bytes (BE)\n    let mut acc: Field = 0;\n    for i in 0..32 {\n        acc = acc * 256 + (input.schnorr.msg32[i] as Field);\n    }\n    assert(acc == digest);\n\n    // Verify signature over computed msg32\n    let pubkey = EmbeddedCurvePoint { x: input.schnorr.pk_x, y: input.schnorr.pk_y, is_infinite: false };\n    let ok = schnorr::verify_signature(pubkey, input.schnorr.sig64, input.schnorr.msg32);\n    assert(ok);\n\n    // Compute leaf hash (tag=12)\n    let leaf_hash = poseidon2_hash_fields([ 12, in_commit0, in_commit1, out_commit ]);\n    // Bind as explicit public input to be consumed by the aggregator\n    assert(public_inputs[0] == leaf_hash);\n}\n","path":"/home/dan/un/usernode-circuits/noir/utxo_merge/src/main.nr"},"51":{"source":"use std::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\nuse std::hash::{blake2s, pedersen_hash};\n\n// the multiples of BN_P that are still less than 2^254 split into (lo, hi)\nglobal BN_P_m: [(Field, Field); 6] = [\n    (0, 0),\n    (201385395114098847380338600778089168199, 64323764613183177041862057485226039389),\n    (62488423307259231297302594124410124942, 128647529226366354083724114970452078779),\n    (263873818421358078677641194902499293141, 192971293839549531125586172455678118168),\n    (124976846614518462594605188248820249884, 257295058452732708167448229940904157558),\n    (326362241728617309974943789026909418083, 321618823065915885209310287426130196947),\n];\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\npub fn verify_signature<let N: u32>(\n    public_key: EmbeddedCurvePoint,\n    signature: [u8; 64],\n    message: [u8; N],\n) -> bool {\n    //scalar lo/hi from bytes\n    let sig_s = scalar_from_bytes(signature, 0);\n    let sig_e = scalar_from_bytes(signature, 32);\n    // pub_key is on Grumpkin curve\n    let mut is_ok = (public_key.y * public_key.y == public_key.x * public_key.x * public_key.x - 17)\n        & (!public_key.is_infinite);\n\n    if ((sig_s.lo != 0) | (sig_s.hi != 0)) & ((sig_e.lo != 0) | (sig_e.hi != 0)) {\n        let (r_is_infinite, result) =\n            calculate_signature_challenge(public_key, sig_s, sig_e, message);\n\n        is_ok &= !r_is_infinite;\n        for i in 0..32 {\n            is_ok &= result[i] == signature[32 + i];\n        }\n    } else {\n        is_ok = false;\n    }\n    is_ok\n}\n\npub fn assert_valid_signature<let N: u32>(\n    public_key: EmbeddedCurvePoint,\n    signature: [u8; 64],\n    message: [u8; N],\n) {\n    //scalar lo/hi from bytes\n    let sig_s = scalar_from_bytes(signature, 0);\n    let sig_e = scalar_from_bytes(signature, 32);\n\n    // assert pub_key is on Grumpkin curve\n    assert(public_key.y * public_key.y == public_key.x * public_key.x * public_key.x - 17);\n    assert(public_key.is_infinite == false);\n    // assert signature is not null\n    assert((sig_s.lo != 0) | (sig_s.hi != 0));\n    assert((sig_e.lo != 0) | (sig_e.hi != 0));\n\n    let (r_is_infinite, result) = calculate_signature_challenge(public_key, sig_s, sig_e, message);\n\n    assert(!r_is_infinite);\n    for i in 0..32 {\n        assert(result[i] == signature[32 + i]);\n    }\n}\n\nfn calculate_signature_challenge<let N: u32>(\n    public_key: EmbeddedCurvePoint,\n    sig_s: EmbeddedCurveScalar,\n    sig_e: EmbeddedCurveScalar,\n    message: [u8; N],\n) -> (bool, [u8; 32]) {\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    let reduced_sig_e = normalize_signature(sig_e);\n    let r = multi_scalar_mul([g1, public_key], [sig_s, reduced_sig_e]);\n    // compare the _hashes_ rather than field elements modulo r\n    let pedersen_hash = pedersen_hash([r.x, public_key.x, public_key.y]);\n    let pde: [u8; 32] = pedersen_hash.to_be_bytes();\n\n    let mut hash_input = [0; N + 32];\n    for i in 0..32 {\n        hash_input[i] = pde[i];\n    }\n    for i in 0..N {\n        hash_input[32 + i] = message[i];\n    }\n\n    let result = blake2s(hash_input);\n    (r.is_infinite, result)\n}\n\nunconstrained fn __gt(a: Field, b: Field) -> bool {\n    b.lt(a)\n}\n\n// gets the quotient of lo/hi when divided by BN254_Fq modulus\nunconstrained fn __get_quotient(hi: Field, lo: Field) -> u32 {\n    let mut q: u32 = 0;\n    let mut r_hi = hi;\n    let mut r_lo = lo;\n    let MODULUS = BN_P_m[1];\n\n    for _ in 1..6 {\n        // check if rhi, rlo is larger than BN_P\n        let borrow = r_lo.lt(MODULUS.0);\n\n        if borrow {\n            r_lo = r_lo + TWO_POW_128;\n            // rlo is always larger than BN_P lo now\n            r_hi = r_hi - 1;\n        }\n\n        let MODULUS_hi = MODULUS.1;\n\n        let gt_flag = !r_hi.lt(MODULUS_hi);\n\n        if gt_flag {\n            r_hi = r_hi - MODULUS.1;\n            r_lo = r_lo - MODULUS.0;\n            if TWO_POW_128.lt(r_lo) | TWO_POW_128.lt(r_hi) {\n                break;\n            }\n            q += 1;\n        }\n    }\n    q\n}\n\n// this method reduces the signature to the range [0, BN254_Fq_MODULUS)\nfn normalize_signature(sig_e: EmbeddedCurveScalar) -> EmbeddedCurveScalar {\n    let mut hi = sig_e.hi;\n    let mut lo = sig_e.lo;\n    // get the quotient\n    let q = unsafe { __get_quotient(hi, lo) };\n    let MODULUSmq = (BN_P_m[q].0, BN_P_m[q].1);\n    let MODULUS = BN_P_m[1];\n    // remove MODULUS * q from lo/hi\n    let borrow = unsafe { __gt(MODULUSmq.0, lo) };\n    // rlo, rhi is the signature without the multiple of MODULUS\n    let rlo = lo - MODULUSmq.0 + borrow as Field * TWO_POW_128;\n    let rhi = hi - borrow as Field - MODULUSmq.1;\n    // now we validate that rlo and rhi are positive\n    rlo.assert_max_bit_size::<128>();\n    rhi.assert_max_bit_size::<128>();\n    // validate that rlo, rhi is smaller than MODULUS\n    // if the lo is larger than the modulus lo we have to get a borrow\n    let borrow = unsafe { __gt(rlo, MODULUS.0) };\n    let rplo = MODULUS.0 - rlo + borrow as Field * TWO_POW_128;\n    let rphi = MODULUS.1 - rhi - borrow as Field;\n    // check that rplo and rphi are positive\n    rplo.assert_max_bit_size::<128>();\n    rphi.assert_max_bit_size::<128>();\n    EmbeddedCurveScalar::new(rlo, rhi)\n}\n\n//Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\nfn scalar_from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n    let mut v: Field = 1;\n    let mut lo: Field = 0;\n    let mut hi: Field = 0;\n    for i in 0..16 {\n        lo = lo + (bytes[offset + 31 - i] as Field) * v;\n        hi = hi + (bytes[offset + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    let sig_s = EmbeddedCurveScalar::new(lo, hi);\n    sig_s\n}\n\nmod test {\n    use super::normalize_signature;\n    use super::verify_signature;\n    use std::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar};\n\n    #[test]\n    fn test_zero_signature() {\n        let public_key: EmbeddedCurvePoint = EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860,\n            is_infinite: false,\n        };\n        let signature: [u8; 64] = [0; 64];\n        let message: [u8; _] = [2; 64]; // every message\n        let verified = verify_signature(public_key, signature, message);\n        assert(!verified);\n    }\n\n    #[test]\n    fn smoke_test() {\n        let message: [u8; 10] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n        let pub_key_x: Field = 0x04b260954662e97f00cab9adb773a259097f7a274b83b113532bce27fa3fb96a;\n        let pub_key_y: Field = 0x2fd51571db6c08666b0edfbfbc57d432068bccd0110a39b166ab243da0037197;\n        let signature: [u8; 64] = [\n            1, 13, 119, 112, 212, 39, 233, 41, 84, 235, 255, 93, 245, 172, 186, 83, 157, 253, 76,\n            77, 33, 128, 178, 15, 214, 67, 105, 107, 177, 234, 77, 48, 27, 237, 155, 84, 39, 84,\n            247, 27, 22, 8, 176, 230, 24, 115, 145, 220, 254, 122, 135, 179, 171, 4, 214, 202, 64,\n            199, 19, 84, 239, 138, 124, 12,\n        ];\n\n        let pub_key = EmbeddedCurvePoint { x: pub_key_x, y: pub_key_y, is_infinite: false };\n        let valid_signature = verify_signature(pub_key, signature, message);\n        assert(valid_signature);\n        super::assert_valid_signature(pub_key, signature, message);\n    }\n\n    #[test]\n    fn test_normalize_signature() {\n        let sig_e = EmbeddedCurveScalar::new(\n            201385395114098847380338600778112493540,\n            64323764613183177041862057485226039389,\n        );\n        let normalized = normalize_signature(sig_e);\n        let expected = EmbeddedCurveScalar::new(23325341, 0);\n        assert(normalized == expected);\n    }\n\n    #[test]\n    fn test_normalize_signature_2() {\n        let sig_e = EmbeddedCurveScalar::new(\n            263873818421358078677641194902522618482,\n            192971293839549531125586172455678118168,\n        );\n        let normalized = normalize_signature(sig_e);\n        let expected = EmbeddedCurveScalar::new(23325341, 0);\n        assert(normalized == expected);\n    }\n\n}\n\nmod bench {\n    use super::{assert_valid_signature, verify_signature};\n    use std::embedded_curve_ops::EmbeddedCurvePoint;\n\n    #[export]\n    pub fn bench_verify_signature(\n        public_key: EmbeddedCurvePoint,\n        signature: [u8; 64],\n        message: [u8; 32],\n    ) -> bool {\n        verify_signature(public_key, signature, message)\n    }\n\n    #[export]\n    pub fn bench_assert_valid_signature(\n        public_key: EmbeddedCurvePoint,\n        signature: [u8; 64],\n        message: [u8; 32],\n    ) {\n        assert_valid_signature(public_key, signature, message)\n    }\n}\n","path":"/home/dan/nargo/github.com/noir-lang/schnorr/v0.1.3/src/lib.nr"}},"names":["main"],"brillig_names":["__get_quotient","__gt","decompose_hint","directive_invert","directive_integer_quotient","directive_to_radix"]}